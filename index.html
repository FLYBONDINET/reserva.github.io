<!DOCTYPE html><html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Puzzle Piece Tracker</title>
<style>
  :root{
    --bg:#0f172a; /* slate-900 */
    --panel:#111827; /* gray-900 */
    --soft:#1f2937; /* gray-800 */
    --text:#e5e7eb; /* gray-200 */
    --accent:#22c55e; /* green-500 */
    --accent2:#ef4444; /* red-500 */
    --grid:#ffffff88;
    --cover:#22c55e55;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  header{padding:16px 20px;border-bottom:1px solid #00000055;background:linear-gradient(180deg,#0b122a,#0f172a)}
  h1{margin:0;font-size:18px;letter-spacing:.2px}
  .wrap{display:grid;grid-template-columns:320px 1fr;gap:14px;height:calc(100vh - 62px)}
  aside{background:var(--panel);padding:14px;overflow:auto}
  label{display:block;font-size:12px;margin:10px 0 6px;opacity:.9}
  input[type="number"], input[type="text"], input[type="file"], select{
    width:100%;padding:10px;border:1px solid #00000066;border-radius:10px;background:var(--soft);color:var(--text);
  }
  button{appearance:none;border:none;border-radius:12px;padding:10px 12px;margin:6px 4px 0 0;cursor:pointer;background:#334155;color:var(--text)}
  button.primary{background:var(--accent);color:#06260f;font-weight:700}
  button.warn{background:var(--accent2)}
  .btn-row{display:flex;flex-wrap:wrap;gap:6px}
  .hint{font-size:12px;opacity:.85;margin-top:6px;line-height:1.3}
  .canvas-wrap{position:relative;height:100%;background:#0b1022;display:flex;align-items:center;justify-content:center}
  canvas{max-width:100%;max-height:100%;background:#0b1022;border-radius:14px;box-shadow:0 10px 30px #0005}
  .badge{display:inline-block;font-size:12px;background:#1f2937;padding:6px 8px;border-radius:999px;margin-right:6px}
  .row{display:flex;align-items:center;gap:8px}
  .divider{height:1px;background:#00000066;margin:12px 0}
  .small{font-size:12px;opacity:.8}
  .legend{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  .chip{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;background:#0b122a;border:1px solid #00000055;font-size:12px}
  .swatch{width:14px;height:14px;border-radius:4px;display:inline-block}
  .kbd{background:#111827;border:1px solid #0007;border-radius:6px;padding:2px 6px;font-size:12px}
  .progress{height:8px;background:#111827;border-radius:999px;overflow:hidden}
  .bar{height:100%;background:var(--accent);width:0%}
</style>
</head>
<body>
<header>
  <h1>üß© Puzzle Piece Tracker ‚Äî Marca, tach√° o tap√° piezas</h1>
</header>
<div class="wrap">
  <aside>
    <div class="row">
      <span class="badge">1</span>
      <strong>Carg√° la imagen del rompecabezas</strong>
    </div>
    <label for="imgFile">Imagen (recomendado subir la oficial del puzzle)</label>
    <input id="imgFile" type="file" accept="image/*" />
    <label for="imgUrl">‚Ä¶o peg√° URL (GitHub, CDN, etc.)</label>
    <input id="imgUrl" type="text" placeholder="https://‚Ä¶/tu_mapa.jpg" />
    <div class="btn-row">
      <button id="btnLoad">Cargar imagen</button>
    </div><div class="divider"></div>

<div class="row">
  <span class="badge">2</span>
  <strong>Defin√≠ la cuadr√≠cula</strong>
</div>
<label>Columnas √ó Filas</label>
<div class="row">
  <input id="cols" type="number" value="50" min="1" style="width:110px" />
  <span>√ó</span>
  <input id="rows" type="number" value="30" min="1" style="width:110px" />
  <button id="btnGrid" class="primary">Aplicar</button>
</div>
<p class="hint">Por defecto 50√ó30 = 1500 piezas (proporci√≥n t√≠pica del puzzle que mencionaste).</p>

<div class="divider"></div>

<div class="row">
  <span class="badge">3</span>
  <strong>Marc√° piezas</strong>
</div>
<div class="legend">
  <span class="chip"><span class="swatch" style="background:transparent;border:1px dashed #fff6"></span> Libre</span>
  <span class="chip"><span class="swatch" style="background:var(--cover)"></span> Tapada</span>
  <span class="chip">‚ùå Tachada</span>
</div>
<p class="hint">Click: alterna <b>Tapada</b> ‚Üî <b>Libre</b> ¬∑ Shift+Click: <b>Tachar</b> / destachar ¬∑ Bot√≥n derecho: cicla estados. Doble click: mostrar ID de pieza.</p>

<div class="row" style="gap:6px;margin-top:6px;flex-wrap:wrap">
  <button id="btnModePaint">Modo Tapar</button>
  <button id="btnModeStrike">Modo Tachar</button>
  <button id="btnClearSelection" class="warn">Limpiar selecci√≥n</button>
</div>

<div class="divider"></div>

<strong>Progreso</strong>
<div class="progress" aria-hidden="true"><div id="bar" class="bar"></div></div>
<p class="small"><span id="countDone">0</span>/<span id="countTotal">0</span> piezas marcadas</p>

<div class="divider"></div>

<strong>Guardar / Cargar</strong>
<div class="btn-row">
  <button id="btnSave">Guardar en este navegador</button>
  <button id="btnLoadState">Cargar guardado</button>
  <button id="btnExport">Exportar JSON</button>
  <button id="btnImport">Importar JSON</button>
</div>

<div class="divider"></div>

<strong>Compartir / Descargar</strong>
<div class="btn-row">
  <button id="btnDownload">Descargar PNG con marcas</button>
  <button id="btnToggleIndex">Ver IDs</button>
</div>

<p class="hint">Ideal para subir a GitHub Pages: es un solo archivo <code>index.html</code>.</p>

  </aside>  <div class="canvas-wrap">
    <canvas id="canvas" width="1600" height="1200" aria-label="lienzo del puzzle"></canvas>
  </div>
</div><script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // State
  let img = new Image();
  let cols = 50, rows = 30;
  let showIndex = false;
  // 0=libre, 1=tapada, 2=tachada
  let grid = [];
  let mode = 'paint'; // 'paint' tapar, 'strike' tachar

  const els = {
    cols: document.getElementById('cols'),
    rows: document.getElementById('rows'),
    btnGrid: document.getElementById('btnGrid'),
    btnLoad: document.getElementById('btnLoad'),
    imgFile: document.getElementById('imgFile'),
    imgUrl: document.getElementById('imgUrl'),
    btnModePaint: document.getElementById('btnModePaint'),
    btnModeStrike: document.getElementById('btnModeStrike'),
    btnClearSelection: document.getElementById('btnClearSelection'),
    btnSave: document.getElementById('btnSave'),
    btnLoadState: document.getElementById('btnLoadState'),
    btnExport: document.getElementById('btnExport'),
    btnImport: document.getElementById('btnImport'),
    btnDownload: document.getElementById('btnDownload'),
    btnToggleIndex: document.getElementById('btnToggleIndex'),
    bar: document.getElementById('bar'),
    countDone: document.getElementById('countDone'),
    countTotal: document.getElementById('countTotal'),
  };

  function newGrid(){ grid = new Array(cols*rows).fill(0); updateProgress(); }

  function updateCanvasSize(){
    // Fit to container while keeping image aspect
    const wrap = canvas.parentElement;
    const maxW = wrap.clientWidth - 20;
    const maxH = wrap.clientHeight - 20;
    const aspect = img.naturalWidth / img.naturalHeight || 4/3;
    let w = maxW, h = w / aspect;
    if (h > maxH){ h = maxH; w = h * aspect; }
    canvas.width = Math.max(320, Math.floor(w));
    canvas.height = Math.max(240, Math.floor(h));
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if (!img.src) return;
    // Draw base image
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

    // Grid overlay
    const cellW = canvas.width/cols;
    const cellH = canvas.height/rows;

    // Draw covers and strikes
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const idx = r*cols + c;
        const x = c*cellW, y=r*cellH;
        if (grid[idx] === 1){
          ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--cover');
          ctx.fillRect(x,y,cellW,cellH);
        } else if (grid[idx] === 2){
          // strike overlay: subtle tint + X
          ctx.fillStyle = '#ef444455';
          ctx.fillRect(x,y,cellW,cellH);
          ctx.beginPath();
          ctx.strokeStyle = '#ef4444';
          ctx.lineWidth = 2;
          ctx.moveTo(x+3,y+3); ctx.lineTo(x+cellW-3,y+cellH-3);
          ctx.moveTo(x+cellW-3,y+3); ctx.lineTo(x+3,y+cellH-3);
          ctx.stroke();
        }
      }
    }

    // Grid lines
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');
    ctx.lineWidth = 1;
    for(let c=1;c<cols;c++){
      const x = Math.round(c*cellW)+.5;
      ctx.beginPath();
      ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke();
    }
    for(let r=1;r<rows;r++){
      const y = Math.round(r*cellH)+.5;
      ctx.beginPath();
      ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke();
    }

    if (showIndex){
      ctx.fillStyle = 'rgba(0,0,0,.45)';
      ctx.font = '12px ui-sans-serif, system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#ffffff';
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const idx = r*cols + c;
          const label = `${c+1},${r+1}`; // Col,Row human-readable
          ctx.fillText(label, c*cellW + cellW/2, r*cellH + cellH/2);
        }
      }
    }
  }

  function posToIndex(evt){
    const rect = canvas.getBoundingClientRect();
    const x = (evt.clientX - rect.left) * (canvas.width/rect.width);
    const y = (evt.clientY - rect.top) * (canvas.height/rect.height);
    const c = Math.min(cols-1, Math.max(0, Math.floor(x / (canvas.width/cols))));
    const r = Math.min(rows-1, Math.max(0, Math.floor(y / (canvas.height/rows))));
    return {c,r,idx:r*cols+c};
  }

  function toggleCell(idx, action){
    if (action === 'paint') grid[idx] = grid[idx] === 1 ? 0 : 1;
    else if (action === 'strike') grid[idx] = grid[idx] === 2 ? 0 : 2;
    updateProgress();
    draw();
  }

  function cycleCell(idx){
    grid[idx] = (grid[idx] + 1) % 3;
    updateProgress();
    draw();
  }

  function updateProgress(){
    const done = grid.filter(v=>v!==0).length;
    const total = grid.length;
    els.countDone.textContent = done;
    els.countTotal.textContent = total;
    els.bar.style.width = (done*100/Math.max(1,total)).toFixed(1)+"%";
  }

  function saveLocal(){
    const key = storageKey();
    const data = {cols, rows, grid, imgSrc: img.src};
    localStorage.setItem(key, JSON.stringify(data));
    alert('Estado guardado en el navegador.');
  }

  function loadLocal(){
    const key = storageKey();
    const raw = localStorage.getItem(key);
    if(!raw){ alert('No hay guardado para esta combinaci√≥n.'); return; }
    try{
      const data = JSON.parse(raw);
      cols = data.cols; rows = data.rows; grid = data.grid;
      els.cols.value = cols; els.rows.value = rows;
      if (data.imgSrc) img.src = data.imgSrc;
      updateCanvasSize(); updateProgress(); draw();
    }catch(e){ alert('No se pudo cargar.'); }
  }

  function storageKey(){
    // Simple key based on image src + grid size
    const base = (img.src||'noimg').slice(-80);
    return `puzzle-tracker::${base}::${cols}x${rows}`;
  }

  function exportJSON(){
    const blob = new Blob([JSON.stringify({cols,rows,grid}, null, 2)], {type:'application/json'});
    const a = Object.assign(document.createElement('a'), {download: `puzzle_${cols}x${rows}.json`, href: URL.createObjectURL(blob)});
    a.click(); URL.revokeObjectURL(a.href);
  }

  function importJSON(){
    const input = document.createElement('input');
    input.type = 'file'; input.accept = 'application/json';
    input.onchange = e => {
      const file = e.target.files[0]; if(!file) return;
      file.text().then(t=>{
        try{
          const data = JSON.parse(t);
          if (!data.cols || !data.rows || !Array.isArray(data.grid)) throw new Error();
          cols = +data.cols; rows = +data.rows; grid = data.grid.slice();
          els.cols.value = cols; els.rows.value = rows;
          updateCanvasSize(); updateProgress(); draw();
        }catch{ alert('Archivo inv√°lido'); }
      });
    };
    input.click();
  }

  function downloadPNG(){
    // Export current view as PNG
    const link = document.createElement('a');
    link.download = 'puzzle_marcado.png';
    link.href = canvas.toDataURL('image/png');
    link.click();
  }

  // Event wiring
  window.addEventListener('resize', () => { updateCanvasSize(); draw(); });

  canvas.addEventListener('contextmenu', e => { e.preventDefault(); const {idx}=posToIndex(e); cycleCell(idx); });
  canvas.addEventListener('click', e => { const {idx}=posToIndex(e); toggleCell(idx, mode==='paint' && !e.shiftKey ? 'paint' : (mode==='strike' && !e.shiftKey ? 'strike':'paint')); });
  canvas.addEventListener('dblclick', e => { const {c,r}=posToIndex(e); alert(`Pieza Col ${c+1} ¬∑ Fila ${r+1}`); });

  els.btnGrid.addEventListener('click', ()=>{
    cols = Math.max(1, parseInt(els.cols.value||50,10));
    rows = Math.max(1, parseInt(els.rows.value||30,10));
    newGrid(); updateCanvasSize(); draw();
  });

  els.btnLoad.addEventListener('click', async ()=>{
    if (els.imgFile.files && els.imgFile.files[0]){
      img.src = URL.createObjectURL(els.imgFile.files[0]);
    } else if (els.imgUrl.value.trim()){
      img.crossOrigin = 'anonymous';
      img.src = els.imgUrl.value.trim();
    } else {
      alert('Eleg√≠ un archivo o pega una URL.');
    }
  });

  img.onload = () => { updateCanvasSize(); draw(); };

  els.btnModePaint.addEventListener('click', ()=>{ mode='paint'; });
  els.btnModeStrike.addEventListener('click', ()=>{ mode='strike'; });
  els.btnClearSelection.addEventListener('click', ()=>{ grid = grid.map(()=>0); updateProgress(); draw(); });
  els.btnSave.addEventListener('click', saveLocal);
  els.btnLoadState.addEventListener('click', loadLocal);
  els.btnExport.addEventListener('click', exportJSON);
  els.btnImport.addEventListener('click', importJSON);
  els.btnDownload.addEventListener('click', downloadPNG);
  els.btnToggleIndex.addEventListener('click', ()=>{ showIndex=!showIndex; draw(); });

  // Initialize
  newGrid();
  // Optional: set a default image via URL if desired
  // img.src = 'YOUR_DEFAULT_IMAGE_URL_HERE';
})();
</script></body>
</html>
